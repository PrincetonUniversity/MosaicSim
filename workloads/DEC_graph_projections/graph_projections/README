A new implementation of graph projection for DECADES

-----
3 variants:

bit flag (gp_bit_flag) - a projection with a binary edge

counter (gp_bit_counter) - a projection with that counts how many
times the relation was seen

float_weight (gp_float_weight) - a projection that does some floating
calcuation on edge weights.

-----

Each variant contains a "baseline" directory. This is just a standard
version of the algorithm that can be compiled with g++.

$ g++ -O3 -std=c++11 main.cpp -o main

Each variant contains a "decades" directory. This is a standard
version of the algorithm that can be compiled with DEC++. Inlined and
decoupled variants should be correct.

Two variants (gp_bit*) contain experimental decades bit serial
operations. They can be compiled with DEC++ but decoupling is
not valid (only inlined)

To compile a DEC++ version, just do:

$ DEC++ main.cpp

-----

To get inputs read the README in inputs

-----

the pp_kernel is not a graph projection, but a preprocessing step that
might occur after a graph projection has occurred. It is an
elementwise MAX followed by a division and tanh activation.

-----

To run in decades:

./exec <PATH_TO_INPUTS>/x_to_y_graph.txt

Baselines do bi-direction projection so you need to graphs (probably
don't need to worry about this)

./exec <PATH_TO_INPUTS>/x_to_y_graph.txt <PATH_TO_INPUTS>/y_to_x_graph.txt

-----

Interesting to simulate:

gp_float_weights/decades: compare decoupled with non-decoupled
(i.e. inlined) with oracle (1 cycle load/store). With enough run ahead
we should 20x speedup.

gp_bit_flag/decades: compare decoupled with non-decoupled
(i.e. inlined).

gp_bit_flag/decades_bit_serial: only inlined will be valid here. Good
to compare against previous runs in gp_bit_flag/decades. Model
bit serial operations as single cycle?

do the same analysis for gp_bit_counter